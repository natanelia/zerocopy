<!DOCTYPE html>
<html>
<head>
  <title>SharedArrayBuffer vs postMessage - Transfer Time Demo</title>
  <style>
    body { font-family: system-ui; max-width: 900px; margin: 40px auto; padding: 0 20px; }
    h1 { margin-bottom: 5px; }
    .subtitle { color: #666; margin-bottom: 30px; }
    table { width: 100%; border-collapse: collapse; margin: 20px 0; }
    th, td { padding: 12px; text-align: left; border-bottom: 1px solid #ddd; }
    th { background: #f5f5f5; }
    .faster { color: #22c55e; font-weight: bold; }
    .slower { color: #ef4444; }
    #status { padding: 20px; background: #f0f9ff; border-radius: 8px; margin: 20px 0; display: flex; align-items: center; justify-content: space-between; }
    #retry { padding: 10px 20px; background: #3b82f6; color: white; border: none; border-radius: 6px; cursor: pointer; font-size: 14px; }
    #retry:hover { background: #2563eb; }
    #retry:disabled { background: #9ca3af; cursor: not-allowed; }
    .summary { background: #f0fdf4; padding: 20px; border-radius: 8px; margin-top: 30px; }
    .summary h3 { margin-top: 0; color: #166534; }
    small { color: #666; }
  </style>
</head>
<body>
  <h1>ðŸš€ SharedArrayBuffer vs postMessage</h1>
  <p class="subtitle">Measuring data transfer time to 4 workers</p>
  
  <div id="status"><span id="status-text">Initializing...</span><button id="retry" disabled>â†» Run Again</button></div>
  
  <table id="results">
    <thead>
      <tr>
        <th>Data Size</th>
        <th>SharedArrayBuffer</th>
        <th>postMessage (clone)</th>
        <th>Speedup</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
  
  <div id="summary" class="summary" style="display:none">
    <h3>ðŸ“Š Key Insight</h3>
    <div id="summary-content"></div>
  </div>

  <script type="module">
    const statusText = document.getElementById('status-text');
    const retryBtn = document.getElementById('retry');
    const tbody = document.querySelector('#results tbody');
    const summary = document.getElementById('summary');
    const summaryContent = document.getElementById('summary-content');
    
    const SIZES = [
      { label: '100 KB', bytes: 100 * 1024 },
      { label: '500 KB', bytes: 500 * 1024 },
      { label: '1 MB', bytes: 1024 * 1024 },
      { label: '5 MB', bytes: 5 * 1024 * 1024 },
      { label: '10 MB', bytes: 10 * 1024 * 1024 },
      { label: '25 MB', bytes: 25 * 1024 * 1024 },
      { label: '50 MB', bytes: 50 * 1024 * 1024 },
      { label: '100 MB', bytes: 100 * 1024 * 1024 },
      { label: '500 MB', bytes: 500 * 1024 * 1024 },
      { label: '1 GB', bytes: 1024 * 1024 * 1024 },
    ];
    
    async function measureShared(bytes) {
      const buffer = new SharedArrayBuffer(bytes);
      new Uint8Array(buffer).fill(42);
      
      const workers = [];
      for (let i = 0; i < 4; i++) {
        workers.push(new Worker(URL.createObjectURL(new Blob([`
          self.onmessage = e => {
            const arr = new Uint8Array(e.data.buffer);
            let sum = 0;
            for (let i = 0; i < 1000; i++) sum += arr[i];
            self.postMessage({ sum, size: arr.length });
          };
        `], { type: 'application/javascript' }))));
      }
      
      await Promise.all(workers.map(w => new Promise(r => {
        w.onmessage = r;
        w.postMessage({ buffer: new SharedArrayBuffer(8) });
      })));
      
      const start = performance.now();
      await Promise.all(workers.map(w => new Promise(r => {
        w.onmessage = () => { w.terminate(); r(); };
        w.postMessage({ buffer });
      })));
      return performance.now() - start;
    }
    
    async function measureClone(bytes) {
      const buffer = new ArrayBuffer(bytes);
      new Uint8Array(buffer).fill(42);
      
      const workers = [];
      for (let i = 0; i < 4; i++) {
        workers.push(new Worker(URL.createObjectURL(new Blob([`
          self.onmessage = e => {
            const arr = new Uint8Array(e.data.buffer);
            let sum = 0;
            for (let i = 0; i < 1000; i++) sum += arr[i];
            self.postMessage({ sum, size: arr.length });
          };
        `], { type: 'application/javascript' }))));
      }
      
      await Promise.all(workers.map(w => new Promise(r => {
        w.onmessage = r;
        w.postMessage({ buffer: new ArrayBuffer(8) });
      })));
      
      const start = performance.now();
      await Promise.all(workers.map((w, i) => {
        const buf = new ArrayBuffer(bytes);
        new Uint8Array(buf).fill(42);
        return new Promise(r => {
          w.onmessage = () => { w.terminate(); r(); };
          w.postMessage({ buffer: buf });
        });
      }));
      return performance.now() - start;
    }
    
    async function runBenchmark() {
      retryBtn.disabled = true;
      tbody.innerHTML = '';
      summary.style.display = 'none';
      
      // Phase 1: SharedArrayBuffer
      statusText.textContent = 'Testing SharedArrayBuffer...';
      await new Promise(r => setTimeout(r, 100));
      const sharedResults = [];
      for (const { label, bytes } of SIZES) {
        statusText.textContent = `SharedArrayBuffer: ${label}...`;
        await new Promise(r => setTimeout(r, 50));
        sharedResults.push({ label, time: await measureShared(bytes) });
      }
      
      // Phase 2: postMessage clone
      statusText.textContent = 'Testing postMessage...';
      await new Promise(r => setTimeout(r, 100));
      const cloneResults = [];
      const MAX_CLONE_BYTES = 100 * 1024 * 1024; // Skip postMessage for >100MB to avoid crash
      for (const { label, bytes } of SIZES) {
        if (bytes > MAX_CLONE_BYTES) {
          cloneResults.push({ label, time: null, skipped: true });
          continue;
        }
        statusText.textContent = `postMessage: ${label}...`;
        await new Promise(r => setTimeout(r, 50));
        cloneResults.push({ label, time: await measureClone(bytes) });
      }
      
      // Display results
      for (let i = 0; i < SIZES.length; i++) {
        const clone = cloneResults[i];
        const shared = sharedResults[i];
        const row = document.createElement('tr');
        if (clone.skipped) {
          row.innerHTML = `
            <td><strong>${shared.label}</strong></td>
            <td>${shared.time.toFixed(2)}ms</td>
            <td><em>skipped</em></td>
            <td class="faster">âˆž (would crash)</td>
          `;
        } else {
          const speedup = clone.time / shared.time;
          const isFaster = speedup > 1;
          row.innerHTML = `
            <td><strong>${shared.label}</strong></td>
            <td>${shared.time.toFixed(2)}ms</td>
            <td>${clone.time.toFixed(2)}ms</td>
            <td class="${isFaster ? 'faster' : 'slower'}">${speedup.toFixed(1)}x ${isFaster ? 'faster' : 'slower'}</td>
          `;
        }
        tbody.appendChild(row);
      }
      
      statusText.textContent = 'âœ… Benchmark complete!';
      retryBtn.disabled = false;
      summary.style.display = 'block';
      summaryContent.innerHTML = `
        <p><strong>SharedArrayBuffer</strong> passes a reference - workers access the same memory (zero-copy).</p>
        <p><strong>postMessage</strong> uses structured clone - data is copied to each worker.</p>
        <p>The speedup increases with data size because SharedArrayBuffer transfer is O(1) while cloning is O(n).</p>
      `;
    }
    
    retryBtn.addEventListener('click', runBenchmark);
    runBenchmark();
  </script>
</body>
</html>
